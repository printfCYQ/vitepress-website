import{_ as i,c as a,o as t,ae as l}from"./chunks/framework.3fkGreVD.js";const e="/vitepress-website/image/javascript/base/Snipaste_2022-11-28_10-31-02.png",n="/vitepress-website/image/javascript/base/Snipaste_2022-11-28_10-35-44.png",E=JSON.parse('{"title":"原型、原型链","description":"","frontmatter":{},"headers":[],"relativePath":"javascript/base/01.原型-原型链.md","filePath":"javascript/base/01.原型-原型链.md"}'),p={name:"javascript/base/01.原型-原型链.md"};function h(o,s,r,k,d,c){return t(),a("div",null,[...s[0]||(s[0]=[l('<h1 id="原型、原型链" tabindex="-1">原型、原型链 <a class="header-anchor" href="#原型、原型链" aria-label="Permalink to &quot;原型、原型链&quot;">​</a></h1><h2 id="经典图解" tabindex="-1">经典图解 <a class="header-anchor" href="#经典图解" aria-label="Permalink to &quot;经典图解&quot;">​</a></h2><p><img src="'+e+`" alt="An image"></p><h2 id="四个规则" tabindex="-1">四个规则 <a class="header-anchor" href="#四个规则" aria-label="Permalink to &quot;四个规则&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">INFO</p><ol><li>引用类型，都具有对象特性，即可自由扩展属性。</li><li>引用类型，都有一个隐式原型 <strong>proto</strong> 属性，属性值是一个普通的对象。</li><li>引用类型，隐式原型 <strong>proto</strong> 的属性值指向它的构造函数的显式原型 prototype 属性值。</li><li>当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 <strong>proto</strong>（也就是它的构造函数的显式原型 prototype）中寻找。</li></ol></div><h2 id="什么是原型对象-实例-构造函数" tabindex="-1">什么是原型对象？实例？构造函数？ <a class="header-anchor" href="#什么是原型对象-实例-构造函数" aria-label="Permalink to &quot;什么是原型对象？实例？构造函数？&quot;">​</a></h2><blockquote><p>创建一个对象</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> M</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> o3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> M</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;o3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><ul><li>实例就是对象，在本例中 o3 就是实例，M 就是构造函数。</li><li>实例通过 new 一个构造函数生成的。</li><li>从上图中可以知道，实例的<strong>protpo</strong>指向的是原型对象。</li><li>实例的构造函数的 prototype 也是指向的原型对象。</li><li>原型对象的 construor 指向的是构造函数。</li></ul><p><img src="`+n+`" alt="An image"></p><h2 id="原型" tabindex="-1">原型 <a class="header-anchor" href="#原型" aria-label="Permalink to &quot;原型&quot;">​</a></h2><p>JS 中的对象包含了一个 prototype 的内部属性，这个属性所对应的就是该对象的原型。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><ol><li>定义：原型是 function 对象的一个属性，它定义了构造函数制造出的对象的公共祖 先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。</li><li>利用原型特点和概念，可以提取共有属性。</li><li>对象属性的增删和原型上属性增删改查。</li><li>对象如何查看原型 ==&gt; 隐式属性 <strong>proto</strong>。</li><li>对象如何查看对象的构造函数 ==&gt; constructor。</li></ol></div><h2 id="原型链" tabindex="-1">原型链 <a class="header-anchor" href="#原型链" aria-label="Permalink to &quot;原型链&quot;">​</a></h2><ul><li><p>proto 是每个对象都有的属性，而 js 里万物皆对象，所以会形成一条 proto 连起来的链条，递归访问 proto 必须最终到头，且值为 null，当 js 引擎查找对象属性时，先查找对象本身是否存在该属性，如果不存在，会在原型链中查找，但不会查找自身的 prototype。</p></li><li><p>简单理解就是原型组成的链，对象的<strong>proto</strong>它的是原型，而原型也是一个对象，也有<strong>proto</strong>属性，原型的<strong>proto</strong>又是原型的原型，就这样可以一直通过<strong>proto</strong>想上找，这就是原型链，当向上找找到 Object 的原型的时候，这条原型链就算到头了。</p></li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><ol><li>如何构成原型链?</li><li>原型链上属性的增删改查 原型链上的增删改查和原型基本上是一致的。只有本人有的权限，子孙是没有的。</li><li>谁调用的方法内部 this 就是谁-原型案例</li><li>绝大多数对象的最终都会继承自 Object.prototype</li><li>Object.create(原型);</li><li>原型方法上的重写</li></ol></div><h2 id="mdn" tabindex="-1">MDN <a class="header-anchor" href="#mdn" aria-label="Permalink to &quot;MDN&quot;">​</a></h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></p><ul><li>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 <strong>proto</strong> ）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。</li></ul></blockquote><h2 id="原型以及原型链对应的关系" tabindex="-1">原型以及原型链对应的关系 <a class="header-anchor" href="#原型以及原型链对应的关系" aria-label="Permalink to &quot;原型以及原型链对应的关系&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><blockquote><p>首先 js 里万物皆对象，每个对象都有 <code>proto</code> 的属性，所以会形成一条 proto 连起来的链条，递归访问 proto 必须最&gt;终到头，且值为 null，当 js 引擎查找对象属性时，先查找对象本身是否存在该属性，如果不存在，会在原型链中查找，但不会查找自身的 prototype。</p></blockquote><h2 id="补" tabindex="-1">补 <a class="header-anchor" href="#补" aria-label="Permalink to &quot;补&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不是所有的对象都继承 Object.prototype</span></span></code></pre></div>`,23)])])}const y=i(p,[["render",h]]);export{E as __pageData,y as default};
