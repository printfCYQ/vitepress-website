import{_ as e,C as s,c as d,o as u,j as t,a as r,G as i,w as n}from"./chunks/framework.3fkGreVD.js";const j=JSON.parse('{"title":"定义","description":"","frontmatter":{},"headers":[],"relativePath":"javascript/design/index.md","filePath":"javascript/design/index.md"}'),f={name:"javascript/design/index.md"},b={id:"开放封闭原则-open-close-principle",tabindex:"-1"},p={id:"里氏代换原则-liskov-substitution-principle",tabindex:"-1"},g={id:"依赖倒转原则-dependence-inversion-principle",tabindex:"-1"},a={id:"接口隔离原则-interface-segregation-principle",tabindex:"-1"},y={id:"迪米特法则-最少知道原则-demeter-principle",tabindex:"-1"},m={id:"单一职责原则-principle-of-single-responsibility",tabindex:"-1"};function P(x,l,k,v,C,D){const o=s("font");return u(),d("div",null,[l[51]||(l[51]=t("h1",{id:"定义",tabindex:"-1"},[r("定义 "),t("a",{class:"header-anchor",href:"#定义","aria-label":'Permalink to "定义"'},"​")],-1)),t("blockquote",null,[i(o,{style:{color:"rgb(87, 96, 106)"}},{default:n(()=>[...l[0]||(l[0]=[r("设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案",-1)])]),_:1}),i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[1]||(l[1]=[r("设计模式是前人解决某个特定场景下对而总结出来的一些解决方案。",-1)])]),_:1})]),l[52]||(l[52]=t("h1",{id:"原则",tabindex:"-1"},[r("原则 "),t("a",{class:"header-anchor",href:"#原则","aria-label":'Permalink to "原则"'},"​")],-1)),t("h2",b,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[2]||(l[2]=[r("开放封闭原则（Open Close Principle）",-1)])]),_:1}),l[3]||(l[3]=r()),l[4]||(l[4]=t("a",{class:"header-anchor",href:"#开放封闭原则-open-close-principle","aria-label":'Permalink to "<font style="color:rgb(36, 41, 47);">开放封闭原则（Open Close Principle）</font>"'},"​",-1))]),t("ul",null,[t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[5]||(l[5]=[r("原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化",-1)])]),_:1})]),t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[6]||(l[6]=[r("描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。",-1)])]),_:1})]),t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[7]||(l[7]=[r("优点：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。",-1)])]),_:1})])]),t("h2",p,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[8]||(l[8]=[r("里氏代换原则（Liskov Substitution Principle）",-1)])]),_:1}),l[9]||(l[9]=r()),l[10]||(l[10]=t("a",{class:"header-anchor",href:"#里氏代换原则-liskov-substitution-principle","aria-label":'Permalink to "<font style="color:rgb(36, 41, 47);">里氏代换原则（Liskov Substitution Principle）</font>"'},"​",-1))]),t("ul",null,[t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[11]||(l[11]=[r("原则思想：使用的基类可以在任何地方使用继承的子类，完美的替换基类。",-1)])]),_:1})]),t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[12]||(l[12]=[r("大概意思是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。",-1)])]),_:1})]),t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[13]||(l[13]=[r("优点：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。",-1)])]),_:1})])]),t("h2",g,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[14]||(l[14]=[r("依赖倒转原则（Dependence Inversion Principle）",-1)])]),_:1}),l[15]||(l[15]=r()),l[16]||(l[16]=t("a",{class:"header-anchor",href:"#依赖倒转原则-dependence-inversion-principle","aria-label":'Permalink to "<font style="color:rgb(36, 41, 47);">依赖倒转原则（Dependence Inversion Principle）</font>"'},"​",-1))]),t("ul",null,[t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[17]||(l[17]=[r("依赖倒置原则的核心思想是面向接口编程.",-1)])]),_:1})]),t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[18]||(l[18]=[r("依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，",-1)])]),_:1})]),t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[19]||(l[19]=[r("这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。",-1)])]),_:1})])]),t("h2",a,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[20]||(l[20]=[r("接口隔离原则（Interface Segregation Principle）",-1)])]),_:1}),l[21]||(l[21]=r()),l[22]||(l[22]=t("a",{class:"header-anchor",href:"#接口隔离原则-interface-segregation-principle","aria-label":'Permalink to "<font style="color:rgb(36, 41, 47);">接口隔离原则（Interface Segregation Principle）</font>"'},"​",-1))]),t("ul",null,[t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[23]||(l[23]=[r("这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。",-1)])]),_:1})]),t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[24]||(l[24]=[r("例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口",-1)])]),_:1})])]),t("h2",y,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[25]||(l[25]=[r("迪米特法则（最少知道原则）（Demeter Principle）",-1)])]),_:1}),l[26]||(l[26]=r()),l[27]||(l[27]=t("a",{class:"header-anchor",href:"#迪米特法则-最少知道原则-demeter-principle","aria-label":'Permalink to "<font style="color:rgb(36, 41, 47);">迪米特法则（最少知道原则）（Demeter Principle）</font>"'},"​",-1))]),t("ul",null,[t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[28]||(l[28]=[r("原则思想：一个对象应当对其他对象有尽可能少地了解，简称类间解耦",-1)])]),_:1})]),t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[29]||(l[29]=[r("大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。",-1)])]),_:1})]),t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[30]||(l[30]=[r("优点：低耦合，高内聚。",-1)])]),_:1})])]),t("h2",m,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[31]||(l[31]=[r("单一职责原则（Principle of single responsibility）",-1)])]),_:1}),l[32]||(l[32]=r()),l[33]||(l[33]=t("a",{class:"header-anchor",href:"#单一职责原则-principle-of-single-responsibility","aria-label":'Permalink to "<font style="color:rgb(36, 41, 47);">单一职责原则（Principle of single responsibility）</font>"'},"​",-1))]),t("ul",null,[t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[34]||(l[34]=[r("原则思想：一个方法只负责一件事情。",-1)])]),_:1})]),t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[35]||(l[35]=[r("描述：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。",-1)])]),_:1})]),t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[36]||(l[36]=[r("优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。",-1)])]),_:1})])]),l[53]||(l[53]=t("h1",{id:"分类",tabindex:"-1"},[r("分类 "),t("a",{class:"header-anchor",href:"#分类","aria-label":'Permalink to "分类"'},"​")],-1)),t("ul",null,[t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[37]||(l[37]=[r("创建型模式，共五种：",-1)])]),_:1}),l[43]||(l[43]=r("**",-1)),i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[38]||(l[38]=[r("工厂方法模式、抽象工厂模式",-1)])]),_:1}),l[44]||(l[44]=r("**",-1)),i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[39]||(l[39]=[r("、",-1)])]),_:1}),l[45]||(l[45]=r("**",-1)),i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[40]||(l[40]=[r("单例模式",-1)])]),_:1}),l[46]||(l[46]=r("**",-1)),i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[41]||(l[41]=[r("、建造者模式、",-1)])]),_:1}),l[47]||(l[47]=r("**",-1)),i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[42]||(l[42]=[r("原型模式。",-1)])]),_:1}),l[48]||(l[48]=r("**",-1)),i(o,{style:{color:"rgb(36, 41, 47)"}})]),t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[49]||(l[49]=[r("结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。",-1)])]),_:1})]),t("li",null,[i(o,{style:{color:"rgb(36, 41, 47)"}},{default:n(()=>[...l[50]||(l[50]=[r("行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。",-1)])]),_:1})])])])}const I=e(f,[["render",P]]);export{j as __pageData,I as default};
